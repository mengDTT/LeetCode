class Solution {
public:
    /*
    以起点为原点，建立坐标轴，不难得出以下递推公式
    dp[i][j] = dp[i-1][j] + dp[i][j-1]。
    解法1：使用递归，直接利用上述递推公式，简单明了，但是部分用力会超时，如果把递归路径画出来，会有许多重复计算项；
    解法2：为了能够利用已经计算出的值，不做无用功，可以使用一个二维数组，把每个节点的路径值保存下来,空间复杂度O(m*n)
    解法3：dp[i][j]只与左侧和上侧的节点值有关，在i=0和j=0的位置，路径全为1，
    1   1   1   1   1
    1  [2]
    1
    1               *

    我们可以使用一个dp[n]的数组，表示某一行的各个点所需的路径。 dp实际代表了上侧的节点值，对于左侧的节点值，由于左边界处值时已知的(为1)，
    通过向右不断推进，我们可以不断的更新dp，进行得到下一行中各点处的路径数目，直至最终到达终点。
    
    */
    int uniquePaths(int m, int n) {
        if( m == 0 || n == 0)
            return 1;

        vector<int> dp(n,1);

        for(auto i = 1; i < m; ++i)
        {
            for(auto j = 1; j < n; ++j)
            {
                dp[j] = dp[j] + dp[j-1];
            }
        }

        return dp[n-1];
    }
};